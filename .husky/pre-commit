#!/bin/sh
# POSIX-compliant pre-commit hook for Terraform
set -eu

# Enable pipefail if using bash
if [ -n "${BASH_VERSION:-}" ]; then
    set -o pipefail
fi

# Color codes for output (POSIX-compatible)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Track if any checks failed
CHECKS_FAILED=0

# Ensure we're in the git repository root
GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    printf "${RED}âŒ Not in a git repository${NC}\n"
    exit 1
}
cd "$GIT_ROOT"

check_terraform_installed() {
    if ! command -v terraform >/dev/null 2>&1; then
        printf "${RED}âŒ Terraform is not installed${NC}\n"
        printf "\n"
        printf "   ðŸ“¦ To install terraform:\n"
        printf "   - Download from: https://www.terraform.io/downloads\n"
        printf "   - Or use package manager:\n"
        printf "     brew install terraform  (macOS)\n"
        printf "     sudo apt-get install terraform  (Ubuntu/Debian)\n"
        printf "\n"
        return 1
    fi
    return 0
}

run_tf_lint() {
    tflint_cmd=""
    
    # Check for tflint in common locations including snap
    if command -v tflint >/dev/null 2>&1; then
        tflint_cmd="tflint"
    elif [ -x "/snap/bin/tflint" ]; then
        tflint_cmd="/snap/bin/tflint"
    else
        printf "${YELLOW}âš ï¸  TFLint is not installed. Skipping linting checks.${NC}\n"
        printf "\n"
        printf "   ðŸ“¦ To install tflint, run ONE of the following:\n"
        printf "\n"
        printf "   Linux/WSL:\n"
        printf "   curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash\n"
        printf "\n"
        printf "   macOS:\n"
        printf "   brew install tflint\n"
        printf "\n"
        printf "   Manual installation:\n"
        printf "   1. Download from: https://github.com/terraform-linters/tflint/releases\n"
        printf "   2. Extract and move to /usr/local/bin/\n"
        printf "   3. Make executable: chmod +x /usr/local/bin/tflint\n"
        printf "\n"
        return 1
    fi

    printf "${BLUE}ðŸ” Running tflint...${NC}\n"
    
    # Initialize tflint if config exists and not initialized
    if [ -f "infra/terraform/.tflint.hcl" ]; then
        if [ ! -d "infra/terraform/.tflint.d" ]; then
            printf "ðŸ“¦ Initializing tflint plugins...\n"
            (cd infra/terraform && $tflint_cmd --init) || {
                printf "${YELLOW}âš ï¸  TFLint init failed, continuing without plugins${NC}\n"
            }
        fi
    fi

    # Run tflint on terraform directory
    if ! (cd infra/terraform && $tflint_cmd --recursive --format compact); then
        printf "${RED}âŒ TFLint found issues${NC}\n"
        printf "ðŸ’¡ Tip: Run 'cd infra/terraform && $tflint_cmd --recursive' to see detailed issues.\n"
        return 1
    fi
    
    printf "${GREEN}âœ… TFLint checks passed${NC}\n"
    return 0
}

run_tf_fmt() {
    printf "${BLUE}ðŸ“ Running terraform fmt...${NC}\n"
    
    # Run terraform fmt recursively on the terraform folder
    if ! terraform fmt -recursive -check infra/terraform/; then
        printf "ðŸŽ¨ Terraform files need formatting. Applying formatting...\n"
        terraform fmt -recursive infra/terraform/
        
        # Add the formatted files back to the staging area
        git add infra/terraform/
        printf "${GREEN}âœ… Terraform files formatted and staged${NC}\n"
    else
        printf "${GREEN}âœ… Terraform files already formatted${NC}\n"
    fi
    
    return 0
}

run_tf_validate() {
    printf "${BLUE}ðŸ”§ Running terraform validate...${NC}\n"
    
    # Run validation in terraform directory
    (
        cd infra/terraform/ || return 1
        
        # Initialize terraform if needed (quietly)
        if [ ! -d ".terraform" ]; then
            printf "ðŸ“¦ Initializing terraform...\n"
            terraform init -backend=false -input=false >/dev/null 2>&1 || {
                printf "${RED}âŒ Terraform init failed${NC}\n"
                return 1
            }
        fi
        
        # Run validation
        if ! terraform validate; then
            printf "${RED}âŒ Terraform validation failed${NC}\n"
            return 1
        fi
    ) || return 1
    
    printf "${GREEN}âœ… Terraform validation passed${NC}\n"
    return 0
}

run_checkov() {
    # Run Checkov if available (security scanning)
    if ! command -v checkov >/dev/null 2>&1; then
        printf "${YELLOW}â„¹ï¸  Checkov is not installed. Skipping security scans.${NC}\n"
        printf "\n"
        printf "   ðŸ” To install Checkov for security scanning:\n"
        printf "\n"
        printf "   Using pip (Python 3.7+):\n"
        printf "   pip3 install checkov\n"
        printf "\n"
        printf "   Using pipx (recommended):\n"
        printf "   pipx install checkov\n"
        printf "\n"
        printf "   Using Homebrew (macOS):\n"
        printf "   brew install checkov\n"
        printf "\n"
        return 1
    fi

    printf "${BLUE}ðŸ” Running Checkov security scan...${NC}\n"
    
    # Run checkov with specific skips
    if ! checkov -d infra/terraform/ \
         --quiet \
         --compact \
         --framework terraform \
         --skip-check CKV_AWS_18,CKV_AWS_19,CKV_AWS_20,CKV_AWS_21 \
         --output cli; then
        printf "${RED}âŒ Checkov found security issues${NC}\n"
        printf "   Run 'checkov -d infra/terraform/' for details.\n"
        return 1
    fi
    
    printf "${GREEN}âœ… Checkov security scan passed${NC}\n"
    return 0
}

get_changed_files() {
    # Get staged files
    staged_files=$(git diff --cached --name-only 2>/dev/null || echo "")
    
    # Get files from the current commit (for amend operations)
    head_files=""
    if git rev-parse --verify HEAD >/dev/null 2>&1; then
        head_files=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null || echo "")
    fi
    
    # Combine both file lists
    all_files=""
    if [ -n "$staged_files" ]; then
        all_files="$staged_files"
    fi
    if [ -n "$head_files" ]; then
        if [ -n "$all_files" ]; then
            all_files="$all_files
$head_files"
        else
            all_files="$head_files"
        fi
    fi
    
    # Remove duplicates and empty lines
    if [ -n "$all_files" ]; then
        echo "$all_files" | sort -u | grep -v '^$' || echo ""
    else
        echo ""
    fi
}

run_lint() {
    has_app_changes=false

    changed_files=$(get_changed_files)
}

run_tf_checks() {
    has_tf_changes=false
    
    # Get all changed files (staged or in HEAD for amend)
    changed_files=$(get_changed_files)
    
    # Debug output - show what files were detected
    if [ -n "${DEBUG_PRE_COMMIT:-}" ]; then
        printf "Debug: Changed files detected:\n%s\n\n" "$changed_files"
    fi
    
    # Look for any .tf files or files in directories containing terraform
    if echo "$changed_files" | grep -qE '(\.tf$|\.tfvars$|\.hcl$|terraform/)'; then
        has_tf_changes=true
    fi
    
    if [ "$has_tf_changes" = false ]; then
        printf "â„¹ï¸  No Terraform changes detected, skipping checks.\n"
        return 0
    fi
    
    printf "${BLUE}ðŸš€ Running Terraform checks...${NC}\n"
    printf "\n"
    
    # Check if terraform is installed first
    if ! check_terraform_installed; then
        return 1
    fi
    
    # Run all checks, accumulating failures
    failed=0
    
    # Format check (always succeeds but may modify files)
    run_tf_fmt || true
    
    # Validation
    if ! run_tf_validate; then
        failed=$((failed + 1))
    fi
    
    # Linting (optional, warns if not installed)
    if ! run_tf_lint; then
        printf "${YELLOW}âš ï¸  TFLint check skipped or failed${NC}\n"
    fi
    
    # Security scanning (optional, warns if not installed)
    if ! run_checkov; then
        printf "${YELLOW}âš ï¸  Checkov check skipped or failed${NC}\n"
    fi
    
    if [ $failed -gt 0 ]; then
        printf "\n"
        printf "${RED}âŒ Some Terraform checks failed. Please fix the issues before committing.${NC}\n"
        return 1
    fi
    
    printf "\n"
    printf "${GREEN}âœ¨ All Terraform checks complete${NC}\n"
    return 0
}

has_app_changes() {
    has_changes=false
    
    # Get all changed files (staged or in HEAD for amend)
    changed_files=$(get_changed_files)

    if echo "$changed_files" | grep -qE '^(apps|libs)/'; then
        has_changes=true
    fi

    if [ "$has_changes" = false ]; then
        return 0
    fi

    return 1
}

run_lint() {
    # Run nx lint for affected projects
    echo "ðŸ“ Running nx lint on affected projects..."
    if ! npx nx affected:lint --base=HEAD~1; then
        echo "âŒ Linting failed. Please fix the errors before committing."
        return 1
    fi
    echo "âœ… Linting passed."
}

run_fmt_check() {
    echo "ðŸŽ¨ Checking code formatting..."
    if ! npx nx format:check --base=HEAD~1; then
        echo "âŒ Code formatting issues found."
        echo "ðŸ’¡ Run 'pnpm format' to fix formatting issues."
        return 1
    fi
    echo "âœ… Code formatting check passed."
}

run_typecheck() {
    changed_files=$(get_changed_files)
    if echo "$changed_files" | grep -qE "\.(ts|tsx)$"; then
        echo "ðŸ”§ Running TypeScript type checking..."
        if ! npx nx run-many --target=typecheck --all --parallel; then
            echo "âŒ TypeScript type checking failed. Please fix the errors before committing."
            return 1
        fi
        echo "âœ… TypeScript type checking passed."
    fi
}

run_quality_checks() {

    if ! has_app_changes; then
        printf "â„¹ï¸  No application changes detected, skipping checks.\n"
        return 0
    fi
    echo "ðŸ” Detected changes in apps/ or libs/ - running code quality checks..."
 
    run_lint || return 1
    run_fmt_check || return 1
    run_typecheck || return 1

    echo "âœ¨ All code quality checks complete."
}

main() {
    if ! run_tf_checks; then
        printf "${RED}âŒ Pre-commit checks failed${NC}\n"
        exit 1
    fi

    if ! run_quality_checks; then
        printf "${RED}âŒ Pre-commit checks failed${NC}\n"
        exit 1
    fi
    
    printf "${GREEN}âœ… All pre-commit checks passed${NC}\n"
    exit 0
}

# Trap to ensure we return to original directory on exit
trap 'cd "$GIT_ROOT" 2>/dev/null || true' EXIT

main "$@"