name: Deploy App Simple

on:
  push:
    branches: [main, infra/*]
    paths:
      - 'infra/**'
      - 'apps/**'
      - 'libs/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'nx.json'
      - 'tsconfig*.json'
      - '.github/workflows/**'
  workflow_run:
    workflows: ["Terraform Deploy v2"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

permissions:
  id-token: write
  contents: read

jobs:
  common-env:
    uses: ./.github/workflows/common-env.yml

  infrastructure:
    needs: [common-env]
    if: |
      github.event_name != 'workflow_run'
    uses: ./.github/workflows/terraform-deploy-v2.yml
    with:
      environment: ${{ github.event.inputs.environment || 'dev' }}
      action: 'apply'
    secrets: inherit
    permissions:
      id-token: write
      contents: read
      pull-requests: write

  deploy:
    runs-on: ubuntu-latest
    needs: [common-env, infrastructure]
    if: |
      always() && 
      needs.common-env.result == 'success' &&
      (needs.infrastructure.result == 'success' || needs.infrastructure.result == 'skipped' || github.event.workflow_run.conclusion == 'success')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm

      - name: Build application
        run: |
          echo "🔨 Building all applications..."
          npx nx run-many --target=build --configuration=production --all --exclude="*-e2e"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.0"

      - name: Get infrastructure outputs
        id: infra
        run: |
          ENV="${{ github.event.inputs.environment || 'dev' }}"
          echo "🔍 Getting infrastructure outputs for environment: $ENV"
          
          # Try to use outputs from infrastructure job first
          BUCKET_NAME="${{ needs.infrastructure.outputs.s3-bucket-name }}"
          DISTRIBUTION_ID="${{ needs.infrastructure.outputs.cloudfront-distribution-id }}"
          WEBSITE_URL="${{ needs.infrastructure.outputs.website-url }}"
          
          # If not available from job outputs, get from terraform state
          if [ -z "$BUCKET_NAME" ]; then
            cd infra/terraform
            
            # Initialize Terraform with environment-specific backend config
            terraform init \
              -backend-config="environments/$ENV/backend.tfvars" \
              -reconfigure
            
            # Get outputs
            BUCKET_NAME=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
            DISTRIBUTION_ID=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "")
            WEBSITE_URL=$(terraform output -raw website_url 2>/dev/null || echo "")
          fi
          
          echo "s3-bucket=$BUCKET_NAME" >> $GITHUB_OUTPUT
          echo "cloudfront-id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT
          echo "website-url=$WEBSITE_URL" >> $GITHUB_OUTPUT
          
          echo "📦 S3 Bucket: $BUCKET_NAME"
          echo "☁️ CloudFront ID: $DISTRIBUTION_ID"
          echo "🌐 Website URL: $WEBSITE_URL"

      - name: Deploy to S3
        id: deploy
        run: |
          BUCKET_NAME="${{ steps.infra.outputs.s3-bucket }}"
          
          if [ -z "$BUCKET_NAME" ]; then
            echo "❌ No S3 bucket found. Infrastructure may not be deployed."
            exit 1
          fi
          
          echo "📦 Deploying to S3 bucket: $BUCKET_NAME"
          
          # Track if any files were changed
          FILES_CHANGED=false
          
          # Deploy container app to root
          if [ -d "apps/container/dist" ]; then
            echo "📤 Syncing container app to root..."
            # Check for changes before syncing
            aws s3 sync apps/container/dist/ s3://$BUCKET_NAME/ \
              --delete \
              --cache-control "public, max-age=60" \
              --exclude "*" \
              --include "index.html" \
              --include "404.html" \
              --dryrun | grep -q "upload:\|delete:" && FILES_CHANGED=true
            
            aws s3 sync apps/container/dist/ s3://$BUCKET_NAME/ \
              --delete \
              --cache-control "public, max-age=60" \
              --exclude "*" \
              --include "index.html" \
              --include "404.html"
            
            aws s3 sync apps/container/dist/ s3://$BUCKET_NAME/ \
              --delete \
              --exclude "index.html" \
              --exclude "404.html" \
              --cache-control "public, max-age=31536000, immutable"
          fi
          
          # Deploy micro-frontends
          for app_dir in apps/*/; do
            app_name=$(basename "$app_dir")
            if [[ "$app_name" != "container" && "$app_name" != *"-e2e" ]]; then
              if [ -d "apps/$app_name/dist" ]; then
                echo "📤 Syncing $app_name micro-frontend..."
                # Check for changes
                aws s3 sync "apps/$app_name/dist/" "s3://$BUCKET_NAME/$app_name/" \
                  --cache-control "public, max-age=31536000, immutable" \
                  --dryrun | grep -q "upload:\|delete:" && FILES_CHANGED=true
                
                aws s3 sync "apps/$app_name/dist/" "s3://$BUCKET_NAME/$app_name/" \
                  --cache-control "public, max-age=31536000, immutable"
              fi
            fi
          done
          
          echo "files-changed=$FILES_CHANGED" >> $GITHUB_OUTPUT

      - name: Invalidate CloudFront
        if: steps.infra.outputs.cloudfront-id != '' && steps.deploy.outputs.files-changed == 'true'
        run: |
          DISTRIBUTION_ID="${{ steps.infra.outputs.cloudfront-id }}"
          echo "🔄 Creating CloudFront invalidation for distribution: $DISTRIBUTION_ID"
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$DISTRIBUTION_ID" \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "✅ CloudFront invalidation created: $INVALIDATION_ID"
      
      - name: Skip CloudFront Invalidation
        if: steps.infra.outputs.cloudfront-id != '' && steps.deploy.outputs.files-changed != 'true'
        run: |
          echo "ℹ️ No files changed during deployment. Skipping CloudFront invalidation."
          echo "💡 CloudFront will serve cached content until TTL expires."

      - name: Display deployment info
        run: |
          echo "🎉 Application deployment successful!"
          echo "🌍 Environment: ${{ github.event.inputs.environment || 'dev' }}"
          echo "📦 S3 Bucket: ${{ steps.infra.outputs.s3-bucket }}"
          echo "☁️ CloudFront ID: ${{ steps.infra.outputs.cloudfront-id }}"
          echo "🌐 Website URL: ${{ steps.infra.outputs.website-url }}"